// Code generated by protoc-gen-gogo.
// source: github.com/TheThingsNetwork/ttn/api/protocol/lorawan/lorawan.proto
// DO NOT EDIT!

/*
	Package lorawan is a generated protocol buffer package.

	It is generated from these files:
		github.com/TheThingsNetwork/ttn/api/protocol/lorawan/lorawan.proto

	It has these top-level messages:
		Metadata
		TxConfiguration
		ActivationMetadata
		PHYPayload
		MHdr
		MACPayload
		FHdr
		FCtrl
*/
package lorawan

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import github_com_TheThingsNetwork_ttn_core_types "github.com/TheThingsNetwork/ttn/core/types"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
const _ = proto.ProtoPackageIsVersion1

type Modulation int32

const (
	Modulation_LORA Modulation = 0
	Modulation_FSK  Modulation = 1
)

var Modulation_name = map[int32]string{
	0: "LORA",
	1: "FSK",
}
var Modulation_value = map[string]int32{
	"LORA": 0,
	"FSK":  1,
}

func (x Modulation) String() string {
	return proto.EnumName(Modulation_name, int32(x))
}
func (Modulation) EnumDescriptor() ([]byte, []int) { return fileDescriptorLorawan, []int{0} }

type Region int32

const (
	Region_EU863_870 Region = 0
	Region_US902_928 Region = 1
	Region_CN779_787 Region = 2
	Region_EU433     Region = 3
	Region_AU915_928 Region = 4
	Region_CN470_510 Region = 5
)

var Region_name = map[int32]string{
	0: "EU863_870",
	1: "US902_928",
	2: "CN779_787",
	3: "EU433",
	4: "AU915_928",
	5: "CN470_510",
}
var Region_value = map[string]int32{
	"EU863_870": 0,
	"US902_928": 1,
	"CN779_787": 2,
	"EU433":     3,
	"AU915_928": 4,
	"CN470_510": 5,
}

func (x Region) String() string {
	return proto.EnumName(Region_name, int32(x))
}
func (Region) EnumDescriptor() ([]byte, []int) { return fileDescriptorLorawan, []int{1} }

type Metadata struct {
	Modulation Modulation `protobuf:"varint,11,opt,name=modulation,proto3,enum=lorawan.Modulation" json:"modulation,omitempty"`
	DataRate   string     `protobuf:"bytes,12,opt,name=data_rate,json=dataRate,proto3" json:"data_rate,omitempty"`
	BitRate    uint32     `protobuf:"varint,13,opt,name=bit_rate,json=bitRate,proto3" json:"bit_rate,omitempty"`
	CodingRate string     `protobuf:"bytes,14,opt,name=coding_rate,json=codingRate,proto3" json:"coding_rate,omitempty"`
}

func (m *Metadata) Reset()                    { *m = Metadata{} }
func (m *Metadata) String() string            { return proto.CompactTextString(m) }
func (*Metadata) ProtoMessage()               {}
func (*Metadata) Descriptor() ([]byte, []int) { return fileDescriptorLorawan, []int{0} }

type TxConfiguration struct {
	Modulation Modulation `protobuf:"varint,11,opt,name=modulation,proto3,enum=lorawan.Modulation" json:"modulation,omitempty"`
	DataRate   string     `protobuf:"bytes,12,opt,name=data_rate,json=dataRate,proto3" json:"data_rate,omitempty"`
	BitRate    uint32     `protobuf:"varint,13,opt,name=bit_rate,json=bitRate,proto3" json:"bit_rate,omitempty"`
	CodingRate string     `protobuf:"bytes,14,opt,name=coding_rate,json=codingRate,proto3" json:"coding_rate,omitempty"`
}

func (m *TxConfiguration) Reset()                    { *m = TxConfiguration{} }
func (m *TxConfiguration) String() string            { return proto.CompactTextString(m) }
func (*TxConfiguration) ProtoMessage()               {}
func (*TxConfiguration) Descriptor() ([]byte, []int) { return fileDescriptorLorawan, []int{1} }

type ActivationMetadata struct {
	DevAddr *github_com_TheThingsNetwork_ttn_core_types.DevAddr `protobuf:"bytes,1,opt,name=dev_addr,json=devAddr,proto3,customtype=github.com/TheThingsNetwork/ttn/core/types.DevAddr" json:"dev_addr,omitempty"`
	NwkSKey *github_com_TheThingsNetwork_ttn_core_types.NwkSKey `protobuf:"bytes,2,opt,name=nwk_s_key,json=nwkSKey,proto3,customtype=github.com/TheThingsNetwork/ttn/core/types.NwkSKey" json:"nwk_s_key,omitempty"`
}

func (m *ActivationMetadata) Reset()                    { *m = ActivationMetadata{} }
func (m *ActivationMetadata) String() string            { return proto.CompactTextString(m) }
func (*ActivationMetadata) ProtoMessage()               {}
func (*ActivationMetadata) Descriptor() ([]byte, []int) { return fileDescriptorLorawan, []int{2} }

type PHYPayload struct {
	Mhdr       *MHdr       `protobuf:"bytes,1,opt,name=mhdr" json:"mhdr,omitempty"`
	MACPayload *MACPayload `protobuf:"bytes,2,opt,name=MAC_payload,json=mACPayload" json:"MAC_payload,omitempty"`
	Mic        []byte      `protobuf:"bytes,3,opt,name=mic,proto3" json:"mic,omitempty"`
}

func (m *PHYPayload) Reset()                    { *m = PHYPayload{} }
func (m *PHYPayload) String() string            { return proto.CompactTextString(m) }
func (*PHYPayload) ProtoMessage()               {}
func (*PHYPayload) Descriptor() ([]byte, []int) { return fileDescriptorLorawan, []int{3} }

func (m *PHYPayload) GetMhdr() *MHdr {
	if m != nil {
		return m.Mhdr
	}
	return nil
}

func (m *PHYPayload) GetMACPayload() *MACPayload {
	if m != nil {
		return m.MACPayload
	}
	return nil
}

type MHdr struct {
	MType uint32 `protobuf:"varint,1,opt,name=m_type,json=mType,proto3" json:"m_type,omitempty"`
	Major uint32 `protobuf:"varint,2,opt,name=major,proto3" json:"major,omitempty"`
}

func (m *MHdr) Reset()                    { *m = MHdr{} }
func (m *MHdr) String() string            { return proto.CompactTextString(m) }
func (*MHdr) ProtoMessage()               {}
func (*MHdr) Descriptor() ([]byte, []int) { return fileDescriptorLorawan, []int{4} }

type MACPayload struct {
	FHdr       *FHdr  `protobuf:"bytes,1,opt,name=f_hdr,json=fHdr" json:"f_hdr,omitempty"`
	FPort      uint32 `protobuf:"varint,2,opt,name=f_port,json=fPort,proto3" json:"f_port,omitempty"`
	FRMPayload []byte `protobuf:"bytes,3,opt,name=FRM_payload,json=fRMPayload,proto3" json:"FRM_payload,omitempty"`
}

func (m *MACPayload) Reset()                    { *m = MACPayload{} }
func (m *MACPayload) String() string            { return proto.CompactTextString(m) }
func (*MACPayload) ProtoMessage()               {}
func (*MACPayload) Descriptor() ([]byte, []int) { return fileDescriptorLorawan, []int{5} }

func (m *MACPayload) GetFHdr() *FHdr {
	if m != nil {
		return m.FHdr
	}
	return nil
}

type FHdr struct {
	DevAddr *github_com_TheThingsNetwork_ttn_core_types.DevAddr `protobuf:"bytes,1,opt,name=dev_addr,json=devAddr,proto3,customtype=github.com/TheThingsNetwork/ttn/core/types.DevAddr" json:"dev_addr,omitempty"`
	FCtrl   *FCtrl                                              `protobuf:"bytes,2,opt,name=f_ctrl,json=fCtrl" json:"f_ctrl,omitempty"`
	FCnt    uint32                                              `protobuf:"varint,3,opt,name=f_cnt,json=fCnt,proto3" json:"f_cnt,omitempty"`
	FOpts   [][]byte                                            `protobuf:"bytes,4,rep,name=f_opts,json=fOpts" json:"f_opts,omitempty"`
}

func (m *FHdr) Reset()                    { *m = FHdr{} }
func (m *FHdr) String() string            { return proto.CompactTextString(m) }
func (*FHdr) ProtoMessage()               {}
func (*FHdr) Descriptor() ([]byte, []int) { return fileDescriptorLorawan, []int{6} }

func (m *FHdr) GetFCtrl() *FCtrl {
	if m != nil {
		return m.FCtrl
	}
	return nil
}

type FCtrl struct {
	Adr       bool   `protobuf:"varint,1,opt,name=adr,proto3" json:"adr,omitempty"`
	AdrAckReq bool   `protobuf:"varint,2,opt,name=adr_ack_req,json=adrAckReq,proto3" json:"adr_ack_req,omitempty"`
	Ack       bool   `protobuf:"varint,3,opt,name=ack,proto3" json:"ack,omitempty"`
	FPending  bool   `protobuf:"varint,4,opt,name=f_pending,json=fPending,proto3" json:"f_pending,omitempty"`
	FOptsLen  []byte `protobuf:"bytes,5,opt,name=f_opts_len,json=fOptsLen,proto3" json:"f_opts_len,omitempty"`
}

func (m *FCtrl) Reset()                    { *m = FCtrl{} }
func (m *FCtrl) String() string            { return proto.CompactTextString(m) }
func (*FCtrl) ProtoMessage()               {}
func (*FCtrl) Descriptor() ([]byte, []int) { return fileDescriptorLorawan, []int{7} }

func init() {
	proto.RegisterType((*Metadata)(nil), "lorawan.Metadata")
	proto.RegisterType((*TxConfiguration)(nil), "lorawan.TxConfiguration")
	proto.RegisterType((*ActivationMetadata)(nil), "lorawan.ActivationMetadata")
	proto.RegisterType((*PHYPayload)(nil), "lorawan.PHYPayload")
	proto.RegisterType((*MHdr)(nil), "lorawan.MHdr")
	proto.RegisterType((*MACPayload)(nil), "lorawan.MACPayload")
	proto.RegisterType((*FHdr)(nil), "lorawan.FHdr")
	proto.RegisterType((*FCtrl)(nil), "lorawan.FCtrl")
	proto.RegisterEnum("lorawan.Modulation", Modulation_name, Modulation_value)
	proto.RegisterEnum("lorawan.Region", Region_name, Region_value)
}
func (m *Metadata) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Metadata) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Modulation != 0 {
		data[i] = 0x58
		i++
		i = encodeVarintLorawan(data, i, uint64(m.Modulation))
	}
	if len(m.DataRate) > 0 {
		data[i] = 0x62
		i++
		i = encodeVarintLorawan(data, i, uint64(len(m.DataRate)))
		i += copy(data[i:], m.DataRate)
	}
	if m.BitRate != 0 {
		data[i] = 0x68
		i++
		i = encodeVarintLorawan(data, i, uint64(m.BitRate))
	}
	if len(m.CodingRate) > 0 {
		data[i] = 0x72
		i++
		i = encodeVarintLorawan(data, i, uint64(len(m.CodingRate)))
		i += copy(data[i:], m.CodingRate)
	}
	return i, nil
}

func (m *TxConfiguration) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *TxConfiguration) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Modulation != 0 {
		data[i] = 0x58
		i++
		i = encodeVarintLorawan(data, i, uint64(m.Modulation))
	}
	if len(m.DataRate) > 0 {
		data[i] = 0x62
		i++
		i = encodeVarintLorawan(data, i, uint64(len(m.DataRate)))
		i += copy(data[i:], m.DataRate)
	}
	if m.BitRate != 0 {
		data[i] = 0x68
		i++
		i = encodeVarintLorawan(data, i, uint64(m.BitRate))
	}
	if len(m.CodingRate) > 0 {
		data[i] = 0x72
		i++
		i = encodeVarintLorawan(data, i, uint64(len(m.CodingRate)))
		i += copy(data[i:], m.CodingRate)
	}
	return i, nil
}

func (m *ActivationMetadata) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ActivationMetadata) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DevAddr != nil {
		data[i] = 0xa
		i++
		i = encodeVarintLorawan(data, i, uint64(m.DevAddr.Size()))
		n1, err := m.DevAddr.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.NwkSKey != nil {
		data[i] = 0x12
		i++
		i = encodeVarintLorawan(data, i, uint64(m.NwkSKey.Size()))
		n2, err := m.NwkSKey.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *PHYPayload) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *PHYPayload) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Mhdr != nil {
		data[i] = 0xa
		i++
		i = encodeVarintLorawan(data, i, uint64(m.Mhdr.Size()))
		n3, err := m.Mhdr.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.MACPayload != nil {
		data[i] = 0x12
		i++
		i = encodeVarintLorawan(data, i, uint64(m.MACPayload.Size()))
		n4, err := m.MACPayload.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if len(m.Mic) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintLorawan(data, i, uint64(len(m.Mic)))
		i += copy(data[i:], m.Mic)
	}
	return i, nil
}

func (m *MHdr) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *MHdr) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MType != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintLorawan(data, i, uint64(m.MType))
	}
	if m.Major != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintLorawan(data, i, uint64(m.Major))
	}
	return i, nil
}

func (m *MACPayload) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *MACPayload) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FHdr != nil {
		data[i] = 0xa
		i++
		i = encodeVarintLorawan(data, i, uint64(m.FHdr.Size()))
		n5, err := m.FHdr.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.FPort != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintLorawan(data, i, uint64(m.FPort))
	}
	if len(m.FRMPayload) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintLorawan(data, i, uint64(len(m.FRMPayload)))
		i += copy(data[i:], m.FRMPayload)
	}
	return i, nil
}

func (m *FHdr) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *FHdr) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DevAddr != nil {
		data[i] = 0xa
		i++
		i = encodeVarintLorawan(data, i, uint64(m.DevAddr.Size()))
		n6, err := m.DevAddr.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.FCtrl != nil {
		data[i] = 0x12
		i++
		i = encodeVarintLorawan(data, i, uint64(m.FCtrl.Size()))
		n7, err := m.FCtrl.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.FCnt != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintLorawan(data, i, uint64(m.FCnt))
	}
	if len(m.FOpts) > 0 {
		for _, b := range m.FOpts {
			data[i] = 0x22
			i++
			i = encodeVarintLorawan(data, i, uint64(len(b)))
			i += copy(data[i:], b)
		}
	}
	return i, nil
}

func (m *FCtrl) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *FCtrl) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Adr {
		data[i] = 0x8
		i++
		if m.Adr {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.AdrAckReq {
		data[i] = 0x10
		i++
		if m.AdrAckReq {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Ack {
		data[i] = 0x18
		i++
		if m.Ack {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.FPending {
		data[i] = 0x20
		i++
		if m.FPending {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if len(m.FOptsLen) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintLorawan(data, i, uint64(len(m.FOptsLen)))
		i += copy(data[i:], m.FOptsLen)
	}
	return i, nil
}

func encodeFixed64Lorawan(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Lorawan(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintLorawan(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}
func (m *Metadata) Size() (n int) {
	var l int
	_ = l
	if m.Modulation != 0 {
		n += 1 + sovLorawan(uint64(m.Modulation))
	}
	l = len(m.DataRate)
	if l > 0 {
		n += 1 + l + sovLorawan(uint64(l))
	}
	if m.BitRate != 0 {
		n += 1 + sovLorawan(uint64(m.BitRate))
	}
	l = len(m.CodingRate)
	if l > 0 {
		n += 1 + l + sovLorawan(uint64(l))
	}
	return n
}

func (m *TxConfiguration) Size() (n int) {
	var l int
	_ = l
	if m.Modulation != 0 {
		n += 1 + sovLorawan(uint64(m.Modulation))
	}
	l = len(m.DataRate)
	if l > 0 {
		n += 1 + l + sovLorawan(uint64(l))
	}
	if m.BitRate != 0 {
		n += 1 + sovLorawan(uint64(m.BitRate))
	}
	l = len(m.CodingRate)
	if l > 0 {
		n += 1 + l + sovLorawan(uint64(l))
	}
	return n
}

func (m *ActivationMetadata) Size() (n int) {
	var l int
	_ = l
	if m.DevAddr != nil {
		l = m.DevAddr.Size()
		n += 1 + l + sovLorawan(uint64(l))
	}
	if m.NwkSKey != nil {
		l = m.NwkSKey.Size()
		n += 1 + l + sovLorawan(uint64(l))
	}
	return n
}

func (m *PHYPayload) Size() (n int) {
	var l int
	_ = l
	if m.Mhdr != nil {
		l = m.Mhdr.Size()
		n += 1 + l + sovLorawan(uint64(l))
	}
	if m.MACPayload != nil {
		l = m.MACPayload.Size()
		n += 1 + l + sovLorawan(uint64(l))
	}
	l = len(m.Mic)
	if l > 0 {
		n += 1 + l + sovLorawan(uint64(l))
	}
	return n
}

func (m *MHdr) Size() (n int) {
	var l int
	_ = l
	if m.MType != 0 {
		n += 1 + sovLorawan(uint64(m.MType))
	}
	if m.Major != 0 {
		n += 1 + sovLorawan(uint64(m.Major))
	}
	return n
}

func (m *MACPayload) Size() (n int) {
	var l int
	_ = l
	if m.FHdr != nil {
		l = m.FHdr.Size()
		n += 1 + l + sovLorawan(uint64(l))
	}
	if m.FPort != 0 {
		n += 1 + sovLorawan(uint64(m.FPort))
	}
	l = len(m.FRMPayload)
	if l > 0 {
		n += 1 + l + sovLorawan(uint64(l))
	}
	return n
}

func (m *FHdr) Size() (n int) {
	var l int
	_ = l
	if m.DevAddr != nil {
		l = m.DevAddr.Size()
		n += 1 + l + sovLorawan(uint64(l))
	}
	if m.FCtrl != nil {
		l = m.FCtrl.Size()
		n += 1 + l + sovLorawan(uint64(l))
	}
	if m.FCnt != 0 {
		n += 1 + sovLorawan(uint64(m.FCnt))
	}
	if len(m.FOpts) > 0 {
		for _, b := range m.FOpts {
			l = len(b)
			n += 1 + l + sovLorawan(uint64(l))
		}
	}
	return n
}

func (m *FCtrl) Size() (n int) {
	var l int
	_ = l
	if m.Adr {
		n += 2
	}
	if m.AdrAckReq {
		n += 2
	}
	if m.Ack {
		n += 2
	}
	if m.FPending {
		n += 2
	}
	l = len(m.FOptsLen)
	if l > 0 {
		n += 1 + l + sovLorawan(uint64(l))
	}
	return n
}

func sovLorawan(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozLorawan(x uint64) (n int) {
	return sovLorawan(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Metadata) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLorawan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Metadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Metadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Modulation", wireType)
			}
			m.Modulation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLorawan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Modulation |= (Modulation(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLorawan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLorawan
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataRate = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BitRate", wireType)
			}
			m.BitRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLorawan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.BitRate |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CodingRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLorawan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLorawan
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CodingRate = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLorawan(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLorawan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxConfiguration) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLorawan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxConfiguration: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxConfiguration: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Modulation", wireType)
			}
			m.Modulation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLorawan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Modulation |= (Modulation(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLorawan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLorawan
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataRate = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BitRate", wireType)
			}
			m.BitRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLorawan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.BitRate |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CodingRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLorawan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLorawan
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CodingRate = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLorawan(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLorawan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActivationMetadata) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLorawan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActivationMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActivationMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DevAddr", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLorawan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthLorawan
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_TheThingsNetwork_ttn_core_types.DevAddr
			m.DevAddr = &v
			if err := m.DevAddr.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NwkSKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLorawan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthLorawan
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_TheThingsNetwork_ttn_core_types.NwkSKey
			m.NwkSKey = &v
			if err := m.NwkSKey.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLorawan(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLorawan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PHYPayload) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLorawan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PHYPayload: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PHYPayload: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mhdr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLorawan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLorawan
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mhdr == nil {
				m.Mhdr = &MHdr{}
			}
			if err := m.Mhdr.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MACPayload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLorawan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLorawan
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MACPayload == nil {
				m.MACPayload = &MACPayload{}
			}
			if err := m.MACPayload.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mic", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLorawan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthLorawan
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mic = append(m.Mic[:0], data[iNdEx:postIndex]...)
			if m.Mic == nil {
				m.Mic = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLorawan(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLorawan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MHdr) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLorawan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MHdr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MHdr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MType", wireType)
			}
			m.MType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLorawan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.MType |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Major", wireType)
			}
			m.Major = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLorawan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Major |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLorawan(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLorawan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MACPayload) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLorawan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MACPayload: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MACPayload: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FHdr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLorawan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLorawan
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FHdr == nil {
				m.FHdr = &FHdr{}
			}
			if err := m.FHdr.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FPort", wireType)
			}
			m.FPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLorawan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.FPort |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FRMPayload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLorawan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthLorawan
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FRMPayload = append(m.FRMPayload[:0], data[iNdEx:postIndex]...)
			if m.FRMPayload == nil {
				m.FRMPayload = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLorawan(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLorawan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FHdr) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLorawan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FHdr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FHdr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DevAddr", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLorawan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthLorawan
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_TheThingsNetwork_ttn_core_types.DevAddr
			m.DevAddr = &v
			if err := m.DevAddr.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FCtrl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLorawan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLorawan
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FCtrl == nil {
				m.FCtrl = &FCtrl{}
			}
			if err := m.FCtrl.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FCnt", wireType)
			}
			m.FCnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLorawan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.FCnt |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FOpts", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLorawan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthLorawan
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FOpts = append(m.FOpts, make([]byte, postIndex-iNdEx))
			copy(m.FOpts[len(m.FOpts)-1], data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLorawan(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLorawan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FCtrl) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLorawan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FCtrl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FCtrl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Adr", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLorawan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Adr = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdrAckReq", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLorawan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AdrAckReq = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ack", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLorawan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ack = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FPending", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLorawan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FPending = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FOptsLen", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLorawan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthLorawan
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FOptsLen = append(m.FOptsLen[:0], data[iNdEx:postIndex]...)
			if m.FOptsLen == nil {
				m.FOptsLen = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLorawan(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLorawan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipLorawan(data []byte) (n int, err error) {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowLorawan
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowLorawan
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if data[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowLorawan
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthLorawan
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowLorawan
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipLorawan(data[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthLorawan = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowLorawan   = fmt.Errorf("proto: integer overflow")
)

var fileDescriptorLorawan = []byte{
	// 710 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xcc, 0x54, 0xc1, 0x6e, 0xda, 0x4c,
	0x10, 0x8e, 0x03, 0x0e, 0x66, 0x08, 0xf9, 0xad, 0xcd, 0xff, 0x4b, 0xfc, 0x6d, 0x95, 0xa4, 0x96,
	0x2a, 0x55, 0x91, 0x0a, 0x04, 0x92, 0x00, 0x47, 0x42, 0x13, 0x45, 0x4a, 0x48, 0xe8, 0x06, 0x0e,
	0xbd, 0x74, 0x65, 0xec, 0x35, 0xb8, 0x06, 0x2f, 0x31, 0x4b, 0x28, 0x2f, 0xd0, 0x67, 0xc8, 0xad,
	0x2f, 0xd0, 0x37, 0xe8, 0x0b, 0xf4, 0xd8, 0x73, 0x0f, 0x55, 0xd5, 0xbe, 0x48, 0x77, 0xd7, 0x04,
	0x72, 0xa8, 0x54, 0xa9, 0x52, 0xa5, 0x1e, 0xac, 0x9d, 0x6f, 0x66, 0xbe, 0x99, 0x6f, 0x66, 0x59,
	0xe0, 0xa8, 0xe7, 0xf3, 0xfe, 0xa4, 0x9b, 0x77, 0xd8, 0xb0, 0xd0, 0xee, 0xd3, 0x76, 0xdf, 0x0f,
	0x7b, 0xe3, 0x0b, 0xca, 0xa7, 0x2c, 0x0a, 0x0a, 0x9c, 0x87, 0x05, 0x7b, 0xe4, 0x17, 0x46, 0x11,
	0xe3, 0xcc, 0x61, 0x83, 0xc2, 0x80, 0x45, 0xf6, 0xd4, 0x0e, 0xef, 0xce, 0xbc, 0x0a, 0xa0, 0xd4,
	0x1c, 0x3e, 0x78, 0x76, 0xaf, 0x58, 0x8f, 0xf5, 0x58, 0x4c, 0xec, 0x4e, 0x3c, 0x85, 0x14, 0x50,
	0x56, 0xcc, 0xb3, 0x6e, 0x35, 0x30, 0x9a, 0x94, 0xdb, 0xae, 0xcd, 0x6d, 0x54, 0x06, 0x18, 0x32,
	0x77, 0x32, 0xb0, 0xb9, 0xcf, 0xc2, 0x5c, 0x66, 0x47, 0x7b, 0xba, 0x51, 0xda, 0xcc, 0xdf, 0x35,
	0x6a, 0x2e, 0x42, 0xf8, 0x5e, 0x1a, 0x7a, 0x08, 0x69, 0x49, 0x26, 0x91, 0xcd, 0x69, 0x6e, 0x5d,
	0x70, 0xd2, 0xd8, 0x90, 0x0e, 0x2c, 0x30, 0xfa, 0x1f, 0x8c, 0xae, 0xcf, 0xe3, 0x58, 0x56, 0xc4,
	0xb2, 0x38, 0x25, 0xb0, 0x0a, 0x6d, 0x43, 0xc6, 0x61, 0xae, 0x18, 0x35, 0x8e, 0x6e, 0x28, 0x26,
	0xc4, 0x2e, 0x99, 0x60, 0xbd, 0xd3, 0xe0, 0x9f, 0xf6, 0x9b, 0x06, 0x0b, 0x3d, 0xbf, 0x37, 0x89,
	0xe2, 0x66, 0x7f, 0x97, 0xc2, 0x0f, 0x1a, 0xa0, 0xba, 0xc3, 0xfd, 0x1b, 0xd5, 0x67, 0xb1, 0xc6,
	0x17, 0x60, 0xb8, 0xf4, 0x86, 0xd8, 0xae, 0x1b, 0xe5, 0x34, 0x41, 0x5a, 0x3f, 0x3a, 0xfc, 0xfc,
	0x65, 0xbb, 0xf4, 0xab, 0x5b, 0x76, 0x58, 0x44, 0x0b, 0x7c, 0x36, 0xa2, 0xe3, 0xfc, 0x73, 0x7a,
	0x53, 0x17, 0x6c, 0x9c, 0x72, 0x63, 0x03, 0x61, 0x48, 0x87, 0xd3, 0x80, 0x8c, 0x49, 0x40, 0x67,
	0xb9, 0xd5, 0xdf, 0xaa, 0x79, 0x31, 0x0d, 0xae, 0xce, 0xe8, 0x0c, 0xa7, 0xc2, 0xd8, 0xb0, 0xa6,
	0x00, 0xad, 0xd3, 0x97, 0x2d, 0x7b, 0x36, 0x60, 0xb6, 0x8b, 0x1e, 0x43, 0x72, 0xd8, 0x9f, 0x0b,
	0xce, 0x94, 0xb2, 0xcb, 0x9d, 0x9e, 0x0a, 0x1d, 0x2a, 0x84, 0xf6, 0x21, 0xd3, 0xac, 0x37, 0xc8,
	0x28, 0x66, 0x28, 0x19, 0x99, 0xfb, 0xdb, 0xaf, 0x37, 0xe6, 0xc5, 0xc4, 0xf6, 0x17, 0x36, 0x32,
	0x21, 0x31, 0xf4, 0x9d, 0x5c, 0x42, 0x8a, 0xc6, 0xd2, 0xb4, 0xca, 0x90, 0x94, 0x55, 0xd1, 0x7f,
	0xb0, 0x36, 0x24, 0x52, 0x9c, 0x6a, 0x9a, 0xc5, 0xfa, 0xb0, 0x2d, 0x00, 0xfa, 0x17, 0xf4, 0xa1,
	0xfd, 0x9a, 0x45, 0xaa, 0x81, 0xf4, 0x4a, 0x60, 0xf5, 0x01, 0x96, 0x0d, 0x90, 0x05, 0xba, 0x47,
	0x7e, 0x26, 0xf7, 0x44, 0xc9, 0xf5, 0xe6, 0xe5, 0x3d, 0x32, 0x62, 0x11, 0xbf, 0x2b, 0xe4, 0xb5,
	0x04, 0x90, 0xb7, 0x7a, 0x82, 0x9b, 0x8b, 0x29, 0x62, 0x5d, 0xe0, 0xe1, 0xe6, 0xbc, 0xb6, 0xf5,
	0x5e, 0x83, 0xa4, 0x2c, 0xf3, 0x27, 0xee, 0xf1, 0x89, 0xd4, 0xe4, 0xf0, 0x68, 0x30, 0xdf, 0xde,
	0xc6, 0x52, 0x78, 0x43, 0x78, 0x85, 0x46, 0x79, 0xa0, 0x4d, 0x39, 0x9e, 0x13, 0x72, 0xa5, 0x2e,
	0x2b, 0xe6, 0x69, 0x84, 0x3c, 0x9e, 0x87, 0x8d, 0xf8, 0x38, 0x97, 0xdc, 0x49, 0x08, 0xcd, 0xba,
	0x77, 0x29, 0x80, 0xf5, 0x56, 0x03, 0x5d, 0x91, 0xe5, 0xa6, 0xed, 0xb9, 0x54, 0x03, 0x4b, 0x13,
	0x6d, 0x41, 0x46, 0x1c, 0xc4, 0x76, 0x02, 0x12, 0xd1, 0x6b, 0xd5, 0xd3, 0xc0, 0x69, 0xe1, 0xaa,
	0x3b, 0x01, 0xa6, 0xd7, 0x8a, 0xe1, 0x04, 0xaa, 0x8b, 0x64, 0x38, 0x81, 0x7c, 0x2b, 0x62, 0x69,
	0x34, 0x94, 0xbf, 0x71, 0xd1, 0x47, 0xfa, 0x0d, 0xaf, 0x15, 0x63, 0xf4, 0x08, 0x20, 0x56, 0x40,
	0x06, 0x34, 0xcc, 0xe9, 0x6a, 0x73, 0x86, 0x52, 0x71, 0x4e, 0xc3, 0xdd, 0x6d, 0x71, 0x43, 0xcb,
	0x47, 0x67, 0x40, 0xf2, 0xfc, 0x12, 0xd7, 0xcd, 0x15, 0x94, 0x82, 0xc4, 0xc9, 0xd5, 0x99, 0xa9,
	0xed, 0xbe, 0x82, 0x35, 0x4c, 0x7b, 0x32, 0x98, 0x85, 0xf4, 0x71, 0xa7, 0x7a, 0x58, 0x26, 0xd5,
	0x4a, 0x51, 0x64, 0x08, 0xd8, 0xb9, 0xaa, 0x15, 0x4b, 0xa4, 0x56, 0xaa, 0x9a, 0x9a, 0x84, 0x8d,
	0x8b, 0x4a, 0xa5, 0x46, 0x2a, 0xd5, 0x8a, 0xb9, 0x8a, 0xd2, 0xa0, 0x1f, 0x77, 0xf6, 0xcb, 0x65,
	0x33, 0x21, 0x23, 0xf5, 0x4e, 0x6d, 0xef, 0x40, 0x25, 0x26, 0xe3, 0xc4, 0xfd, 0x4a, 0x91, 0x1c,
	0xec, 0x15, 0x4d, 0xfd, 0xc8, 0xfc, 0xf8, 0x6d, 0x4b, 0xfb, 0x24, 0xbe, 0xaf, 0xe2, 0xbb, 0xfd,
	0xbe, 0xb5, 0xd2, 0x5d, 0x53, 0x7f, 0x72, 0xe5, 0x1f, 0x01, 0x00, 0x00, 0xff, 0xff, 0x03, 0x9c,
	0xd8, 0x8d, 0x62, 0x05, 0x00, 0x00,
}
