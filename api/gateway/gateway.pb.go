// Code generated by protoc-gen-gogo.
// source: github.com/TheThingsNetwork/ttn/api/gateway/gateway.proto
// DO NOT EDIT!

/*
	Package gateway is a generated protocol buffer package.

	It is generated from these files:
		github.com/TheThingsNetwork/ttn/api/gateway/gateway.proto

	It has these top-level messages:
		GPSMetadata
		RxMetadata
		TxConfiguration
		Status
*/
package gateway

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"
import semtech "github.com/TheThingsNetwork/ttn/api/gateway/semtech"

import github_com_TheThingsNetwork_ttn_core_types "github.com/TheThingsNetwork/ttn/core/types"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
const _ = proto.ProtoPackageIsVersion1

type GPSMetadata struct {
	Time      int64   `protobuf:"varint,1,opt,name=time,proto3" json:"time,omitempty"`
	Latitude  float32 `protobuf:"fixed32,2,opt,name=latitude,proto3" json:"latitude,omitempty"`
	Longitude float32 `protobuf:"fixed32,3,opt,name=longitude,proto3" json:"longitude,omitempty"`
	Altitude  int32   `protobuf:"varint,4,opt,name=altitude,proto3" json:"altitude,omitempty"`
}

func (m *GPSMetadata) Reset()                    { *m = GPSMetadata{} }
func (m *GPSMetadata) String() string            { return proto.CompactTextString(m) }
func (*GPSMetadata) ProtoMessage()               {}
func (*GPSMetadata) Descriptor() ([]byte, []int) { return fileDescriptorGateway, []int{0} }

type RxMetadata struct {
	GatewayEui *github_com_TheThingsNetwork_ttn_core_types.GatewayEUI `protobuf:"bytes,1,opt,name=gateway_eui,json=gatewayEui,proto3,customtype=github.com/TheThingsNetwork/ttn/core/types.GatewayEUI" json:"gateway_eui,omitempty"`
	Frequency  uint64                                                 `protobuf:"varint,11,opt,name=frequency,proto3" json:"frequency,omitempty"`
	Rssi       float32                                                `protobuf:"fixed32,12,opt,name=rssi,proto3" json:"rssi,omitempty"`
	Snr        float32                                                `protobuf:"fixed32,13,opt,name=snr,proto3" json:"snr,omitempty"`
	// Types that are valid to be assigned to Gateway:
	//	*RxMetadata_Semtech
	Gateway isRxMetadata_Gateway `protobuf_oneof:"gateway"`
}

func (m *RxMetadata) Reset()                    { *m = RxMetadata{} }
func (m *RxMetadata) String() string            { return proto.CompactTextString(m) }
func (*RxMetadata) ProtoMessage()               {}
func (*RxMetadata) Descriptor() ([]byte, []int) { return fileDescriptorGateway, []int{1} }

type isRxMetadata_Gateway interface {
	isRxMetadata_Gateway()
	MarshalTo([]byte) (int, error)
	Size() int
}

type RxMetadata_Semtech struct {
	Semtech *semtech.RxMetadata `protobuf:"bytes,21,opt,name=semtech,oneof"`
}

func (*RxMetadata_Semtech) isRxMetadata_Gateway() {}

func (m *RxMetadata) GetGateway() isRxMetadata_Gateway {
	if m != nil {
		return m.Gateway
	}
	return nil
}

func (m *RxMetadata) GetSemtech() *semtech.RxMetadata {
	if x, ok := m.GetGateway().(*RxMetadata_Semtech); ok {
		return x.Semtech
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*RxMetadata) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _RxMetadata_OneofMarshaler, _RxMetadata_OneofUnmarshaler, _RxMetadata_OneofSizer, []interface{}{
		(*RxMetadata_Semtech)(nil),
	}
}

func _RxMetadata_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*RxMetadata)
	// gateway
	switch x := m.Gateway.(type) {
	case *RxMetadata_Semtech:
		_ = b.EncodeVarint(21<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Semtech); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("RxMetadata.Gateway has unexpected type %T", x)
	}
	return nil
}

func _RxMetadata_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*RxMetadata)
	switch tag {
	case 21: // gateway.semtech
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(semtech.RxMetadata)
		err := b.DecodeMessage(msg)
		m.Gateway = &RxMetadata_Semtech{msg}
		return true, err
	default:
		return false, nil
	}
}

func _RxMetadata_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*RxMetadata)
	// gateway
	switch x := m.Gateway.(type) {
	case *RxMetadata_Semtech:
		s := proto.Size(x.Semtech)
		n += proto.SizeVarint(21<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type TxConfiguration struct {
	Frequency uint64 `protobuf:"varint,1,opt,name=frequency,proto3" json:"frequency,omitempty"`
	Power     int32  `protobuf:"varint,2,opt,name=power,proto3" json:"power,omitempty"`
	// Types that are valid to be assigned to Gateway:
	//	*TxConfiguration_Semtech
	Gateway isTxConfiguration_Gateway `protobuf_oneof:"gateway"`
}

func (m *TxConfiguration) Reset()                    { *m = TxConfiguration{} }
func (m *TxConfiguration) String() string            { return proto.CompactTextString(m) }
func (*TxConfiguration) ProtoMessage()               {}
func (*TxConfiguration) Descriptor() ([]byte, []int) { return fileDescriptorGateway, []int{2} }

type isTxConfiguration_Gateway interface {
	isTxConfiguration_Gateway()
	MarshalTo([]byte) (int, error)
	Size() int
}

type TxConfiguration_Semtech struct {
	Semtech *semtech.TxConfiguration `protobuf:"bytes,11,opt,name=semtech,oneof"`
}

func (*TxConfiguration_Semtech) isTxConfiguration_Gateway() {}

func (m *TxConfiguration) GetGateway() isTxConfiguration_Gateway {
	if m != nil {
		return m.Gateway
	}
	return nil
}

func (m *TxConfiguration) GetSemtech() *semtech.TxConfiguration {
	if x, ok := m.GetGateway().(*TxConfiguration_Semtech); ok {
		return x.Semtech
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*TxConfiguration) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _TxConfiguration_OneofMarshaler, _TxConfiguration_OneofUnmarshaler, _TxConfiguration_OneofSizer, []interface{}{
		(*TxConfiguration_Semtech)(nil),
	}
}

func _TxConfiguration_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*TxConfiguration)
	// gateway
	switch x := m.Gateway.(type) {
	case *TxConfiguration_Semtech:
		_ = b.EncodeVarint(11<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Semtech); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("TxConfiguration.Gateway has unexpected type %T", x)
	}
	return nil
}

func _TxConfiguration_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*TxConfiguration)
	switch tag {
	case 11: // gateway.semtech
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(semtech.TxConfiguration)
		err := b.DecodeMessage(msg)
		m.Gateway = &TxConfiguration_Semtech{msg}
		return true, err
	default:
		return false, nil
	}
}

func _TxConfiguration_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*TxConfiguration)
	// gateway
	switch x := m.Gateway.(type) {
	case *TxConfiguration_Semtech:
		s := proto.Size(x.Semtech)
		n += proto.SizeVarint(11<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// message Status represents a status update from a Gateway.
// See https://gist.github.com/htdvisser/b2b1078005ed770233278a366430f992#stat
type Status struct {
	Timestamp    uint32       `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	Time         int64        `protobuf:"varint,2,opt,name=time,proto3" json:"time,omitempty"`
	Ip           []string     `protobuf:"bytes,11,rep,name=ip" json:"ip,omitempty"`
	Platform     string       `protobuf:"bytes,12,opt,name=platform,proto3" json:"platform,omitempty"`
	ContactEmail string       `protobuf:"bytes,13,opt,name=contact_email,json=contactEmail,proto3" json:"contact_email,omitempty"`
	Description  string       `protobuf:"bytes,14,opt,name=description,proto3" json:"description,omitempty"`
	Region       string       `protobuf:"bytes,15,opt,name=region,proto3" json:"region,omitempty"`
	Gps          *GPSMetadata `protobuf:"bytes,21,opt,name=gps" json:"gps,omitempty"`
	Rtt          uint32       `protobuf:"varint,31,opt,name=rtt,proto3" json:"rtt,omitempty"`
	RxIn         uint32       `protobuf:"varint,41,opt,name=rx_in,json=rxIn,proto3" json:"rx_in,omitempty"`
	RxOk         uint32       `protobuf:"varint,42,opt,name=rx_ok,json=rxOk,proto3" json:"rx_ok,omitempty"`
	TxIn         uint32       `protobuf:"varint,43,opt,name=tx_in,json=txIn,proto3" json:"tx_in,omitempty"`
	TxOk         uint32       `protobuf:"varint,44,opt,name=tx_ok,json=txOk,proto3" json:"tx_ok,omitempty"`
}

func (m *Status) Reset()                    { *m = Status{} }
func (m *Status) String() string            { return proto.CompactTextString(m) }
func (*Status) ProtoMessage()               {}
func (*Status) Descriptor() ([]byte, []int) { return fileDescriptorGateway, []int{3} }

func (m *Status) GetGps() *GPSMetadata {
	if m != nil {
		return m.Gps
	}
	return nil
}

func init() {
	proto.RegisterType((*GPSMetadata)(nil), "gateway.GPSMetadata")
	proto.RegisterType((*RxMetadata)(nil), "gateway.RxMetadata")
	proto.RegisterType((*TxConfiguration)(nil), "gateway.TxConfiguration")
	proto.RegisterType((*Status)(nil), "gateway.Status")
}
func (m *GPSMetadata) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *GPSMetadata) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Time != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintGateway(data, i, uint64(m.Time))
	}
	if m.Latitude != 0 {
		data[i] = 0x15
		i++
		i = encodeFixed32Gateway(data, i, uint32(math.Float32bits(float32(m.Latitude))))
	}
	if m.Longitude != 0 {
		data[i] = 0x1d
		i++
		i = encodeFixed32Gateway(data, i, uint32(math.Float32bits(float32(m.Longitude))))
	}
	if m.Altitude != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintGateway(data, i, uint64(m.Altitude))
	}
	return i, nil
}

func (m *RxMetadata) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RxMetadata) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.GatewayEui != nil {
		data[i] = 0xa
		i++
		i = encodeVarintGateway(data, i, uint64(m.GatewayEui.Size()))
		n1, err := m.GatewayEui.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.Frequency != 0 {
		data[i] = 0x58
		i++
		i = encodeVarintGateway(data, i, uint64(m.Frequency))
	}
	if m.Rssi != 0 {
		data[i] = 0x65
		i++
		i = encodeFixed32Gateway(data, i, uint32(math.Float32bits(float32(m.Rssi))))
	}
	if m.Snr != 0 {
		data[i] = 0x6d
		i++
		i = encodeFixed32Gateway(data, i, uint32(math.Float32bits(float32(m.Snr))))
	}
	if m.Gateway != nil {
		nn2, err := m.Gateway.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += nn2
	}
	return i, nil
}

func (m *RxMetadata_Semtech) MarshalTo(data []byte) (int, error) {
	i := 0
	if m.Semtech != nil {
		data[i] = 0xaa
		i++
		data[i] = 0x1
		i++
		i = encodeVarintGateway(data, i, uint64(m.Semtech.Size()))
		n3, err := m.Semtech.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}
func (m *TxConfiguration) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *TxConfiguration) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Frequency != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintGateway(data, i, uint64(m.Frequency))
	}
	if m.Power != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintGateway(data, i, uint64(m.Power))
	}
	if m.Gateway != nil {
		nn4, err := m.Gateway.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += nn4
	}
	return i, nil
}

func (m *TxConfiguration_Semtech) MarshalTo(data []byte) (int, error) {
	i := 0
	if m.Semtech != nil {
		data[i] = 0x5a
		i++
		i = encodeVarintGateway(data, i, uint64(m.Semtech.Size()))
		n5, err := m.Semtech.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}
func (m *Status) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Status) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Timestamp != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintGateway(data, i, uint64(m.Timestamp))
	}
	if m.Time != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintGateway(data, i, uint64(m.Time))
	}
	if len(m.Ip) > 0 {
		for _, s := range m.Ip {
			data[i] = 0x5a
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if len(m.Platform) > 0 {
		data[i] = 0x62
		i++
		i = encodeVarintGateway(data, i, uint64(len(m.Platform)))
		i += copy(data[i:], m.Platform)
	}
	if len(m.ContactEmail) > 0 {
		data[i] = 0x6a
		i++
		i = encodeVarintGateway(data, i, uint64(len(m.ContactEmail)))
		i += copy(data[i:], m.ContactEmail)
	}
	if len(m.Description) > 0 {
		data[i] = 0x72
		i++
		i = encodeVarintGateway(data, i, uint64(len(m.Description)))
		i += copy(data[i:], m.Description)
	}
	if len(m.Region) > 0 {
		data[i] = 0x7a
		i++
		i = encodeVarintGateway(data, i, uint64(len(m.Region)))
		i += copy(data[i:], m.Region)
	}
	if m.Gps != nil {
		data[i] = 0xaa
		i++
		data[i] = 0x1
		i++
		i = encodeVarintGateway(data, i, uint64(m.Gps.Size()))
		n6, err := m.Gps.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.Rtt != 0 {
		data[i] = 0xf8
		i++
		data[i] = 0x1
		i++
		i = encodeVarintGateway(data, i, uint64(m.Rtt))
	}
	if m.RxIn != 0 {
		data[i] = 0xc8
		i++
		data[i] = 0x2
		i++
		i = encodeVarintGateway(data, i, uint64(m.RxIn))
	}
	if m.RxOk != 0 {
		data[i] = 0xd0
		i++
		data[i] = 0x2
		i++
		i = encodeVarintGateway(data, i, uint64(m.RxOk))
	}
	if m.TxIn != 0 {
		data[i] = 0xd8
		i++
		data[i] = 0x2
		i++
		i = encodeVarintGateway(data, i, uint64(m.TxIn))
	}
	if m.TxOk != 0 {
		data[i] = 0xe0
		i++
		data[i] = 0x2
		i++
		i = encodeVarintGateway(data, i, uint64(m.TxOk))
	}
	return i, nil
}

func encodeFixed64Gateway(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Gateway(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintGateway(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}
func (m *GPSMetadata) Size() (n int) {
	var l int
	_ = l
	if m.Time != 0 {
		n += 1 + sovGateway(uint64(m.Time))
	}
	if m.Latitude != 0 {
		n += 5
	}
	if m.Longitude != 0 {
		n += 5
	}
	if m.Altitude != 0 {
		n += 1 + sovGateway(uint64(m.Altitude))
	}
	return n
}

func (m *RxMetadata) Size() (n int) {
	var l int
	_ = l
	if m.GatewayEui != nil {
		l = m.GatewayEui.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.Frequency != 0 {
		n += 1 + sovGateway(uint64(m.Frequency))
	}
	if m.Rssi != 0 {
		n += 5
	}
	if m.Snr != 0 {
		n += 5
	}
	if m.Gateway != nil {
		n += m.Gateway.Size()
	}
	return n
}

func (m *RxMetadata_Semtech) Size() (n int) {
	var l int
	_ = l
	if m.Semtech != nil {
		l = m.Semtech.Size()
		n += 2 + l + sovGateway(uint64(l))
	}
	return n
}
func (m *TxConfiguration) Size() (n int) {
	var l int
	_ = l
	if m.Frequency != 0 {
		n += 1 + sovGateway(uint64(m.Frequency))
	}
	if m.Power != 0 {
		n += 1 + sovGateway(uint64(m.Power))
	}
	if m.Gateway != nil {
		n += m.Gateway.Size()
	}
	return n
}

func (m *TxConfiguration_Semtech) Size() (n int) {
	var l int
	_ = l
	if m.Semtech != nil {
		l = m.Semtech.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}
func (m *Status) Size() (n int) {
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovGateway(uint64(m.Timestamp))
	}
	if m.Time != 0 {
		n += 1 + sovGateway(uint64(m.Time))
	}
	if len(m.Ip) > 0 {
		for _, s := range m.Ip {
			l = len(s)
			n += 1 + l + sovGateway(uint64(l))
		}
	}
	l = len(m.Platform)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.ContactEmail)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.Region)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.Gps != nil {
		l = m.Gps.Size()
		n += 2 + l + sovGateway(uint64(l))
	}
	if m.Rtt != 0 {
		n += 2 + sovGateway(uint64(m.Rtt))
	}
	if m.RxIn != 0 {
		n += 2 + sovGateway(uint64(m.RxIn))
	}
	if m.RxOk != 0 {
		n += 2 + sovGateway(uint64(m.RxOk))
	}
	if m.TxIn != 0 {
		n += 2 + sovGateway(uint64(m.TxIn))
	}
	if m.TxOk != 0 {
		n += 2 + sovGateway(uint64(m.TxOk))
	}
	return n
}

func sovGateway(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozGateway(x uint64) (n int) {
	return sovGateway(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *GPSMetadata) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GPSMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GPSMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Time |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Latitude", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.Latitude = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Longitude", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.Longitude = float32(math.Float32frombits(v))
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Altitude", wireType)
			}
			m.Altitude = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Altitude |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RxMetadata) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RxMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RxMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GatewayEui", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_TheThingsNetwork_ttn_core_types.GatewayEUI
			m.GatewayEui = &v
			if err := m.GatewayEui.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Frequency", wireType)
			}
			m.Frequency = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Frequency |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rssi", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.Rssi = float32(math.Float32frombits(v))
		case 13:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Snr", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.Snr = float32(math.Float32frombits(v))
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Semtech", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &semtech.RxMetadata{}
			if err := v.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Gateway = &RxMetadata_Semtech{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxConfiguration) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxConfiguration: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxConfiguration: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Frequency", wireType)
			}
			m.Frequency = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Frequency |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Power", wireType)
			}
			m.Power = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Power |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Semtech", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &semtech.TxConfiguration{}
			if err := v.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Gateway = &TxConfiguration_Semtech{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Status) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Status: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Status: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Timestamp |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Time |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ip = append(m.Ip, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Platform", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Platform = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContactEmail", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContactEmail = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Region = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Gps == nil {
				m.Gps = &GPSMetadata{}
			}
			if err := m.Gps.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rtt", wireType)
			}
			m.Rtt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Rtt |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 41:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RxIn", wireType)
			}
			m.RxIn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.RxIn |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 42:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RxOk", wireType)
			}
			m.RxOk = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.RxOk |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 43:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxIn", wireType)
			}
			m.TxIn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.TxIn |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 44:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxOk", wireType)
			}
			m.TxOk = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.TxOk |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipGateway(data []byte) (n int, err error) {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if data[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthGateway
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowGateway
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipGateway(data[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthGateway = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowGateway   = fmt.Errorf("proto: integer overflow")
)

var fileDescriptorGateway = []byte{
	// 561 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x94, 0x53, 0xcd, 0x6e, 0xd3, 0x40,
	0x10, 0xae, 0xf3, 0xd3, 0x92, 0x75, 0xd2, 0x56, 0xdb, 0x82, 0xac, 0x08, 0xb5, 0x55, 0x90, 0x50,
	0xf9, 0x8b, 0x25, 0x7e, 0x0e, 0x3d, 0x12, 0x14, 0x95, 0x1e, 0xa0, 0x68, 0x1b, 0x2e, 0x5c, 0xa2,
	0x8d, 0xb3, 0x71, 0x56, 0x89, 0xbd, 0x66, 0x3d, 0x56, 0x92, 0x17, 0xe0, 0x19, 0x78, 0x24, 0x8e,
	0x48, 0xdc, 0x38, 0x20, 0x04, 0x17, 0x1e, 0x03, 0xef, 0xf8, 0x27, 0xa1, 0x12, 0x42, 0x1c, 0x2c,
	0xcf, 0xf7, 0xcd, 0xec, 0xcc, 0xb7, 0x33, 0xb3, 0xe4, 0xcc, 0x97, 0x30, 0x4d, 0x46, 0x5d, 0x4f,
	0x05, 0xee, 0x60, 0x2a, 0x06, 0x53, 0x19, 0xfa, 0xf1, 0x6b, 0x01, 0x0b, 0xa5, 0x67, 0x2e, 0x40,
	0xe8, 0xf2, 0x48, 0xba, 0x3e, 0x07, 0xb1, 0xe0, 0xab, 0xe2, 0xdf, 0x8d, 0xb4, 0x02, 0x45, 0x77,
	0x72, 0xd8, 0x7e, 0xb4, 0x91, 0xc3, 0x57, 0xbe, 0x72, 0xd1, 0x3f, 0x4a, 0x26, 0x88, 0x10, 0xa0,
	0x95, 0x9d, 0x6b, 0x3f, 0xff, 0x9f, 0x92, 0xb1, 0x08, 0x40, 0x78, 0xd3, 0xe2, 0x9f, 0xa5, 0xe8,
	0x2c, 0x88, 0x7d, 0xfe, 0xe6, 0xea, 0x95, 0x00, 0x3e, 0xe6, 0xc0, 0x29, 0x25, 0x35, 0x90, 0x81,
	0x70, 0xac, 0x13, 0xeb, 0xb4, 0xca, 0xd0, 0xa6, 0x6d, 0x72, 0x63, 0xce, 0x41, 0x42, 0x32, 0x16,
	0x4e, 0x25, 0xe5, 0x2b, 0xac, 0xc4, 0xf4, 0x36, 0x69, 0xcc, 0x55, 0xe8, 0x67, 0xce, 0x2a, 0x3a,
	0xd7, 0x84, 0x39, 0xc9, 0xe7, 0xf9, 0xc9, 0x5a, 0xea, 0xac, 0xb3, 0x12, 0x77, 0x7e, 0x59, 0x84,
	0xb0, 0x65, 0x59, 0xf8, 0x1d, 0xb1, 0x73, 0xa1, 0x43, 0x91, 0x48, 0xac, 0xdf, 0xec, 0x9d, 0x7d,
	0xfd, 0x76, 0xfc, 0xec, 0x5f, 0x77, 0xf4, 0x94, 0x16, 0x2e, 0xac, 0x22, 0x11, 0x77, 0xcf, 0xb3,
	0x0c, 0xfd, 0xb7, 0x17, 0x8c, 0xe4, 0xd9, 0xfa, 0x89, 0x34, 0x22, 0x27, 0x5a, 0xbc, 0x4f, 0x44,
	0xe8, 0xad, 0x1c, 0x3b, 0xcd, 0x5c, 0x63, 0x6b, 0xc2, 0x5c, 0x59, 0xc7, 0xb1, 0x74, 0x9a, 0xa8,
	0x1e, 0x6d, 0xba, 0x4f, 0xaa, 0x71, 0xa8, 0x9d, 0x16, 0x52, 0xc6, 0xa4, 0x2e, 0xd9, 0xc9, 0x1b,
	0xe7, 0xdc, 0x4c, 0x59, 0xfb, 0xf1, 0x41, 0xb7, 0x68, 0xe4, 0xfa, 0x16, 0x2f, 0xb7, 0x58, 0x11,
	0xd5, 0x6b, 0x90, 0x62, 0xaa, 0x9d, 0x0f, 0x16, 0xd9, 0x1b, 0x2c, 0x5f, 0xa8, 0x70, 0x22, 0xfd,
	0x44, 0xa7, 0xad, 0x53, 0xe1, 0x9f, 0x9a, 0xac, 0xeb, 0x9a, 0x0e, 0x49, 0x3d, 0x52, 0x0b, 0xa1,
	0xb1, 0xdf, 0x75, 0x96, 0x01, 0xfa, 0x74, 0xad, 0xc1, 0x46, 0x0d, 0x4e, 0xa9, 0xe1, 0x5a, 0xfa,
	0xbf, 0x08, 0xf9, 0x52, 0x21, 0xdb, 0x57, 0xc0, 0x21, 0x89, 0x4d, 0x7d, 0x33, 0xdc, 0x18, 0x78,
	0x10, 0x61, 0xfd, 0x16, 0x5b, 0x13, 0xe5, 0x1a, 0x54, 0x36, 0xd6, 0x60, 0x97, 0x54, 0x64, 0x94,
	0x16, 0xae, 0x9e, 0x36, 0x58, 0x6a, 0x99, 0xe1, 0x46, 0xe9, 0x1e, 0x4c, 0x94, 0x0e, 0xb0, 0x77,
	0x0d, 0x56, 0x62, 0x7a, 0x87, 0xb4, 0x3c, 0x15, 0x02, 0xf7, 0x60, 0x28, 0x02, 0x2e, 0xe7, 0xd8,
	0xc9, 0x06, 0x6b, 0xe6, 0x64, 0xdf, 0x70, 0xf4, 0x84, 0xd8, 0x63, 0x11, 0x7b, 0x5a, 0x46, 0x46,
	0xb2, 0xb3, 0x8b, 0x21, 0x9b, 0x14, 0xbd, 0x45, 0xb6, 0xb5, 0xf0, 0x8d, 0x73, 0x0f, 0x9d, 0x39,
	0xa2, 0x77, 0x49, 0xd5, 0x8f, 0xe2, 0x7c, 0x10, 0x87, 0xdd, 0xe2, 0x31, 0x6d, 0x2c, 0x32, 0x33,
	0x01, 0x66, 0x8c, 0x1a, 0xc0, 0x39, 0xc6, 0xeb, 0x19, 0x93, 0x1e, 0x90, 0xba, 0x5e, 0x0e, 0x65,
	0xe8, 0xdc, 0x43, 0xae, 0xa6, 0x97, 0x17, 0x61, 0x4e, 0xaa, 0x99, 0x73, 0xbf, 0x20, 0x2f, 0x67,
	0x86, 0x04, 0x8c, 0x7c, 0x90, 0x91, 0x90, 0x47, 0x02, 0x46, 0x3e, 0x2c, 0xc8, 0xcb, 0x59, 0x6f,
	0xff, 0xd3, 0x8f, 0x23, 0xeb, 0x73, 0xfa, 0x7d, 0x4f, 0xbf, 0x8f, 0x3f, 0x8f, 0xb6, 0x46, 0xdb,
	0xf8, 0xb6, 0x9e, 0xfc, 0x0e, 0x00, 0x00, 0xff, 0xff, 0x53, 0x5b, 0x1b, 0xe0, 0x13, 0x04, 0x00,
	0x00,
}
